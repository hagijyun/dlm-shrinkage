#define TRANSPOSE '


#define KALMAN_SEQ_TZHQcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHQcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHQcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHQc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHQdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHQd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHQM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHQ(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZHM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZH(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZQcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZQcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZQcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZQc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZQdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZQd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZQM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZQ(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TZ(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THQcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THQcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THQcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THQc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THQdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THQd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THQM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THQ(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_THM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TH(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TQcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TQcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TQcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TQc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TQdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TQd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TQM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TQ(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Tcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Tc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Td(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_TM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_T(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T[i] * PREFIX ## a; \
    PREFIX ## P <- T[i] * PREFIX ## P * T[i] TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHQcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHQcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHQcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHQc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHQdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHQd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHQM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHQ(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZHM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZH(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZQcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZQcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZQcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZQc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZQdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZQd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZQM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZQ(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Zcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Zc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Zd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_ZM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Z(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HQcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HQcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HQcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HQc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HQdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HQd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HQM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HQ(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Hcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Hc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Hd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_HM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_H(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[i, j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_QcdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Qcd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_QcM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Qc(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_QdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Qd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_QM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_Q(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR[i]; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_cdM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_cd(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_cM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_c(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[i, j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[i, j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_dM(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_d(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d[i] + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_M(PREFIX, y, T, Z, H, RQR, a1, P1, c, d, missing) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
      if (! int_step(missing[i, j])) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
      } \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


#define KALMAN_SEQ_(PREFIX, y, T, Z, H, RQR, a1, P1, c, d) \
{ \
  real PREFIX ## v; \
  vector[rows(T)] PREFIX ## K; \
  real PREFIX ## Finv; \
  vector[rows(T)] PREFIX ## a; \
  matrix[rows(T), rows(T)] PREFIX ## P; \
  vector[rows(T)] PREFIX ## M; \
  real PREFIX ## F; \
  PREFIX ## a <- a1; \
  PREFIX ## P <- P1; \
  for (i in 1:cols(y)) { \
    for (j in 1:rows(y)) { \
       \
        vector[m] PREFIX ## Zj; \
        PREFIX ## Zj <- Z[j] TRANSPOSE; \
        PREFIX ## v <- y[j, i] - c[j] - dot_product(PREFIX ## Zj, PREFIX ## a); \
        PREFIX ## M <- PREFIX ## P * PREFIX ## Zj; \
        PREFIX ## F <- dot_product(PREFIX ## Zj, PREFIX ## M) + H[j]; \
        PREFIX ## Finv <- 1 / PREFIX ## F; \
        PREFIX ## K <- PREFIX ## M * PREFIX ## Finv; \
        PREFIX ## a <- PREFIX ## a + PREFIX ## K * PREFIX ## v; \
        PREFIX ## P <- PREFIX ## P - PREFIX ## K * PREFIX ## M TRANSPOSE; \
        PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE);  \
        lp__ <- lp__  - 0.5 * (log(2 * pi())  \
                               + log(PREFIX ## F) + PREFIX ## Finv * pow(PREFIX ## v, 2.0)); \
       \
    } \
    PREFIX ## a <- d + T * PREFIX ## a; \
    PREFIX ## P <- T * PREFIX ## P * T TRANSPOSE + RQR; \
    PREFIX ## P <- 0.5 * (PREFIX ## P + PREFIX ## P TRANSPOSE); \
  } \
} \


