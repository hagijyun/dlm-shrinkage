// -*- mode: stan -*-
functions {
  {{> dlm}}
}
data {
  int<lower = 1> n;
  int<lower = 1> p; // number of states, i.e. polynomial.
  vector[1] y[n];
  int miss[n];
  real m0;
  real<lower = 0.0> C0;
  real<lower = 0.0> s;
  vector<lower = 0.0>[2] w;
}
transformed data {
  vector[1] g[n];
  vector[1] b[n];
  matrix[2, 1] F[n];
  matrix[2, 2] G[n];
  matrix[2, 2] L;

  for (i in 1:n) {
    F <- rep_matrix(0.0, 1, p);
    F[1, 1, i] <- 1.0;
  }
  g <- rep_array(rep_vector(0.0, 1), n);
  b <- rep_array(rep_vector(0.0, 1), n);
  G <- rep_array(L, n);

}
parameters {
  real<lower = 0.0> sigma;
  vector<lower = 0.0>[2] tau;
  vector<lower = 0.0>[2] lambda[n];
}
transformed parameters {
  vector[1] log_lik[n];
  vector[dlm_filter_return_size(1, p)] dlm[n + 1];
  vector[2] W[n];

  for (i in 1:n) {
    W[i] <- L * pow(sigma * tau[1] * lambda[i], 2) * L ' ;
  }
  {
    vector[n] V;
    V <- rep_vector(pow(sigma, 2), n);
    dlm <- dlm_filter(n, 1, p, y, miss, b, F, V, g, G, W, m0, C0);
    log_lik <- dlm_loglik(n, 1, p, dlm, miss);
  }

}
model {
  vector[n] ll;

  sigma ~ cauchy(0.0, s);
  for (i in 1:n) {
      tau[i] ~ cauchy(0.0, w);
      lambda[i] ~ cauchy(0.0, 1);
  }
  for (i in 1:n) {
    ll[i] <- log_lik[1];
  }
  increment_log_prob(sum(ll));
}
generated quantities {
  vector[p] mu[n + 1];
  vector[p] omega[n];
  vector[p] kalman[n];

 {
   mu <- dlm_filter_bsample_rng(n, 1, p, G, dlm);
 }
  for (i in 1:n) {
    omega[i] <- mu[i + 1] - mu[i];
  }
  for (i in 1:n) {
    kalman[i] <- dlm_get_C(i, 1, p, dlm) * F[i] * dlm_get_Q_inv(i, 1, p, dlm);
  }

}
