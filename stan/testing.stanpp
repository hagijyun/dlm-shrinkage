# include <make_symmetric.stanh>
data {
  int r;
  int n;
  int T;
  matrix[r, T] y;
  matrix[n, r] F;
  vector<lower=0.0>[r] V;
  matrix[n, n] G;
  matrix[n, n] W;
  vector[n] m0;
  matrix[n, n] C0;
}
parameters {
  real foo;
}
transformed parameters {
  real lp;
  { 
    vector[r] LL; 
    vector[n] KALMANF_m; 
    matrix[n, n] KALMANF_C; 
    real KALMANF_f; 
    real KALMANF_Q; 
    real KALMANF_Q_inv; 
    real KALMANF_e; 
    vector[n] KALMANF_A; 
    vector[n] KALMANF_Fj; 
    KALMANF_m <- m0; 
    KALMANF_C <- C0; 
    for (i in 1:T) { 
      KALMANF_m <- G * KALMANF_m; 
      KALMANF_C <- G * KALMANF_C * G ' + W;
      KALMANF_C <- 0.5 * (KALMANF_C + KALMANF_C');
      for (j in 1:r) { 
        KALMANF_Fj <- col(F, j); 
        KALMANF_f <- dot_product(KALMANF_Fj, KALMANF_m); 
        KALMANF_Q <- KALMANF_Fj ' * KALMANF_C * KALMANF_Fj + V[j]; 
        KALMANF_Q_inv <- 1.0 / KALMANF_Q; 
        KALMANF_e <- y[j, i] - KALMANF_f;                      
        KALMANF_A <- KALMANF_C * KALMANF_Fj * KALMANF_Q_inv; 
        KALMANF_m <- KALMANF_m + KALMANF_A * KALMANF_e; 
        KALMANF_C <- KALMANF_C - KALMANF_Q * KALMANF_A * KALMANF_A '; 
        KALMANF_C <- 0.5 * (KALMANF_C + KALMANF_C');
        LL[j] <- (-0.5   
                  * (log(KALMANF_Q)  
                    + KALMANF_Q_inv * pow(KALMANF_e, 2))); 
      } 
      lp__ <- lp__ + sum(LL); 
    } 
  }
}
model {
  foo ~ normal(0, 1);
}
